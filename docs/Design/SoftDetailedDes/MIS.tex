\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

% \usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Name} & {\bf Notes}\\
\midrule
January 17th, 2025 & All & Initial Draft\\
March 24th, 2025 & Mya Hussain & Removed Pythonic Syntax Mentions\\
March 24th, 2025 & Mya Hussain & Added Some References to Local Functions\\
March 24th, 2025 & Mya Hussain & Modified Wrong Environment Variables\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See \href{https://github.com/ssm-lab/capstone--source-code-optimizer/blob/main/docs/SRS/SRS.pdf}{SRS} Documentation.

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications (MIS) for the Source Code Optimizer project. The Source Code Optimizer is a software tool designed to analyse, refactor, and optimise Python source code to improve energy efficiency, maintainability, and performance. This tool incorporates a combination of static code analysis using Pylint, abstract syntax tree (AST) parsing, and custom refactoring techniques to detect and address various code smells in Python programs.

The application allows developers to identify inefficient coding patterns, refactor them into optimized alternatives, and validate the results through built-in testing mechanisms. Key features include support for custom smell detection, energy profiling, and modular refactorers tailored to specific code smells, such as long method chains or inefficient list comprehensions. By automating parts of the optimization process, the Source Code Optimizer helps developers have the option of choosing to reduce emissions and produce more efficient software.

Complementary documents include the System Requirement Specifications (SRS) and Module Guide (MG). The full documentation and implementation can be found at: \url{https://github.com/ssm-lab/capstone--source-code-optimizer}

\section{Notation}

The following table summarizes the primitive data types used by \progname. 

\begin{table}
  \centering
  \renewcommand{\arraystretch}{1.2}
  \noindent 
  \begin{tabular}{l l p{7.5cm}} 
    \toprule 
    \textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
    \midrule
    optional & ? & denotes a variable as optional\\
    any type & Any & any data type is acceptable\\
    character & char & a single symbol or digit\\
    String & str & a sequence of characters\\
    integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
    natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
    real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
    boolean & $\mathbb{B}$ & True or False\\
    code smell & Smell & a collection of data representing a code smell\\
    path & Path & Data object representing a path in a filesystem\\
    list & list[T] & an ordered collection of objects of type T\\
    set & set[T] & an unordered collection of \textit{unique} objects of type T\\
    dictionary & dict[key] = value & data structure containing multiple key-value pairs\\
    AST Node & AST & AST node representing any AST node\\
    AST Constant & Constant & AST node representing a constant\\
    AST Function Definition & FuncDef & AST node representing a function definition\\
    AST Module & Module & AST node representing a Module\\
    AST Class Definition & ClassDef & ast node representing a class definition\\
    AST Call & Call & ast node representing a function call\\
    AST Lambda & Lambda & ast node representing a lambda function\\
    AST List Comprehension & ListComp & ast node representing a list comprehension\\
    AST Generator Expression & GenExp & ast node representing a generator expression\\
    current instance & self & a reference to the current instance of a module\\
    \bottomrule
  \end{tabular}
  \label{tab:mis-notation}
  \caption{MIS Notation}
\end{table}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
  \toprule
  \textbf{Level 1} & \textbf{Level 2}\\
  \midrule
  
  {Hardware-Hiding Module} & None \\
  \midrule
  
  \multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & Smell Module\\
  & BaseRefactorer Module\\
  & MakeStaticRefactorer Module\\
  & UseListAccumulationRefactorer Module\\
  & UseAGeneratorRefactorer Module\\
  & CacheRepeatedCallsRefactorer Module\\
  & LongElementChainRefactorer Module\\
  & LongParameterListRefactorer Module\\
  & LongMessageChainRefactorer Module\\
  & LongLambdaFunctionRefactorer Module\\ 
  & PluginInitiator Module\\
  & BackendCommunicator Module\\ 
  & SmellDetector Module\\
  & FileHighlighter Module\\
  & HoverManager Module\\
  & CacheManager Module\\
  & FilterManager Module\\
  \midrule


  \multirow{3}{0.3\textwidth}{Software Decision Module} & Measurements Module\\
& PylintAnalyzer Module\\
    & Testing Functionality Module\\
& SmellRefactorer Module\\
& RefactorManager Module\\
& EnergyMetrics Module\\
& ViewProvider Module\\
& EventManager Module\\
\bottomrule
\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

~\newpage

\section{MIS of Smell Data Type} \label{mis:smell}
\texttt{Smell}

\subsection{Module}
Contains data related to a code smell.

\subsection{Uses}
None

\subsection{Syntax}
\noindent
\textbf{Exported Constants}: None

\noindent
\textbf{Exported Access Programs}: None

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{absolutePath: str}: Absolute path to the source file containing the smell.
  \item \texttt{column: int}: Starting column in the source file where the smell is detected.
  \item \texttt{confidence: str}: Confidence level for the smell detection.
  \item \texttt{endColumn?: int}: Ending column for the smell location, if applicable.
  \item \texttt{endLine?: int}: Ending line number for the smell location, if applicable.
  \item \texttt{occurences: dict}: Contains positional data related to where the smell is located in a code file.
  \item \texttt{message: str}: Descriptive message explaining the smell.
  \item \texttt{messageId: str}: Unique identifier for the specific message or warning.
  \item \texttt{module: str}: Module or component name containing the smell.
  \item \texttt{obj: str}: Specific object associated with the smell.
  \item \texttt{path: str}: Relative path to the source file from the project root.
  \item \texttt{symbol: str}: Symbol or code construct involved in the smell.
  \item \texttt{type: str}: Type or category of the smell.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
  \item All values provided to the fields of \texttt{Smell} conform to the expected data types and constraints.
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{Smell()}}
\begin{itemize}
  \item \textbf{transition}: Creates a dictionary-like structure with the defined attributes representing a code smell.
  \item \textbf{output}: Returns a \texttt{Smell} instance.
\end{itemize}

\subsubsection{Local Functions}
None.
  

\newpage

\section{MIS of BaseRefactorer} \label{mis:baseR}

\texttt{BaseRefactorer}

\subsection{Module}

The base interface that all refactorers inherit from, providing common functionality for file I/O, AST manipulation, code validation, and energy measurement integration.

\subsection{Uses}

None

\subsection{Syntax}
\noindent
\textbf{Exported Constants}: None

\noindent
\textbf{Exported Access Programs}:

\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
\texttt{BaseRefactorer} & \texttt{output\_dir: Path} & \texttt{self} & None \\\hline
\texttt{refactor} & \texttt{file\_path: Path, smell: Smell, initial\_emissions: $\mathbb{R}$} & None & \texttt{IOError} \\\hline
\texttt{parse\_ast} & \texttt{source: str} & \texttt{AST} & \texttt{SyntaxError} \\\hline
\texttt{validate\_transformation} & \texttt{original: AST, modified: AST} & \texttt{bool} & None \\\hline
\texttt{write\_output} & \texttt{path: Path, content: str} & None & \texttt{IOError} \\\hline
\texttt{measure\_energy} & \texttt{before: float, after: float} & \texttt{float} & None \\\hline
\texttt{apply\_transformation} & \texttt{node: AST} & \texttt{AST} & None \\\hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{output\_dir: Path}: Directory for output files
  \item \texttt{temp\_dir: Path}: Directory for temporary files during processing
  \item \texttt{ast\_cache}: Cache for parsed AST trees
  \item \texttt{transformation\_state}: Tracks current refactoring state
  \item \texttt{energy\_metrics}: Stores energy consumption measurements
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{WORKSPACE\_ROOT}: Root directory of the workspace
  \item \texttt{FILE\_PERMISSIONS}: Required file access permissions
  \item \texttt{TEMP\_DIR\_CONFIG}: Configuration for temporary directory
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item Input files are valid Python scripts
  \item Output directory exists or can be created
  \item Write permissions are available for output directory
  \item AST transformations preserve program semantics
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{BaseRefactorer(output\_dir: Path)}}
\begin{itemize}
  \item \textbf{Transition}: 
    \begin{itemize}
      \item Initializes temporary directory using \texttt{\_create\_temp\_dir}
      \item Sets up AST cache using \texttt{\_setup\_ast\_cache}
      \item Configures transformation state
      \item Initializes energy metrics
    \end{itemize}
  \item \textbf{Output}: \texttt{self}
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{refactor(file\_path: Path, smell: Smell, initial\_emissions: $\mathbb{R}$)}}
\begin{itemize}
  \item \textbf{Transition}:
    \begin{itemize}
      \item Reads and parses source file using \texttt{parse\_ast}
      \item Applies transformation using \texttt{apply\_transformation}
      \item Validates changes using \texttt{validate\_transformation}
      \item Measures energy impact using \texttt{measure\_energy}
      \item Writes output using \texttt{write\_output} if valid
      \item Cleans up using \texttt{\_cleanup\_temp\_files}
    \end{itemize}
  \item \textbf{Output}: None
  \item \textbf{Exception}: \texttt{IOError} if file operations fail
\end{itemize}

\paragraph{\texttt{parse\_ast(source: str)}}
\begin{itemize}
  \item \textbf{Transition}: Parses source code into AST representation
  \item \textbf{Output}: AST object
  \item \textbf{Exception}: \texttt{SyntaxError} for invalid Python code
\end{itemize}

\paragraph{\texttt{validate\_transformation(original: AST, modified: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Verifies semantic equivalence between ASTs
  \item \textbf{Output}: Boolean indicating valid transformation
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{write\_output(path: Path, content: str)}}
\begin{itemize}
  \item \textbf{Transition}: Writes transformed code after \texttt{\_validate\_permissions}
  \item \textbf{Output}: None
  \item \textbf{Exception}: \texttt{IOError} for file system issues
\end{itemize}

\paragraph{\texttt{measure\_energy(before: float, after: float)}}
\begin{itemize}
  \item \textbf{Transition}: Calculates energy consumption difference
  \item \textbf{Output}: Float representing energy impact
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{apply\_transformation(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Abstract method for specific refactoring logic
  \item \textbf{Output}: Modified AST
  \item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_create\_temp\_dir()}}
\begin{itemize}
  \item \textbf{Transition}: Creates a temporary directory for storing intermediate files
  \item \textbf{Output}: Path to created directory
  \item \textbf{Exception}: \texttt{IOError} if directory creation fails
\end{itemize}

\paragraph{\texttt{\_setup\_ast\_cache()}}
\begin{itemize}
  \item \textbf{Transition}: Initializes cache for storing parsed AST nodes
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_cleanup\_temp\_files()}}
\begin{itemize}
  \item \textbf{Transition}: Removes all temporary files and directories
  \item \textbf{Output}: None
  \item \textbf{Exception}: \texttt{IOError} if cleanup fails
\end{itemize}

\paragraph{\texttt{\_validate\_permissions()}}
\begin{itemize}
  \item \textbf{Transition}: Verifies read/write permissions for target files
  \item \textbf{Output}: Boolean indicating if permissions are valid
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_update\_energy\_metrics()}}
\begin{itemize}
  \item \textbf{Transition}: Updates energy consumption measurements
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
\end{itemize}

\newpage

\section{MIS of LongMessageChainRefactorer} \label{mis:LMC}

\texttt{LongMessageChainRefactorer}

\subsection{Module}

LongMessageChainRefactorer is a module that identifies and refactors long message chains in Python code to improve readability, maintainability, and performance. It specifically handles long chains by breaking them into separate statements, ensuring proper refactoring while maintaining the original functionality.

\subsection{Uses}

\begin{itemize}
  \item Uses \texttt{Smell} interface for data access
  \item Inherits from \texttt{BaseRefactorer}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|p{1in}|p{1in}|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
\texttt{apply\_transformation} & \texttt{node: AST} & \texttt{AST} & None \\\hline
\texttt{identify\_chains} & \texttt{node: AST} & \texttt{List[Chain]} & None \\\hline
\texttt{extract\_methods} & \texttt{chain: Chain} & \texttt{List[str]} & None \\\hline
\texttt{generate\_vars} & \texttt{methods: List[str]} & \texttt{List[str]} & None \\\hline
\end{tabularx}
\end{center}


\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item \texttt{chain\_patterns}: Dictionary mapping chain types to their patterns
  \item \texttt{intermediate\_vars}: List of generated variable names
  \item \texttt{indentation\_map}: Mapping of line numbers to indentation levels
\end{itemize}

\subsubsection{Environment Variables}
Inherits from \texttt{BaseRefactorer}

\subsubsection{Assumptions}
\begin{itemize}
  \item Message chains are properly terminated
  \item Variable names generated do not conflict with existing ones
  \item Indentation is consistent within code blocks
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{apply\_transformation(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}:
    \begin{itemize}
      \item Identifies message chains using \texttt{identify\_chains}
      \item Extracts methods using \texttt{extract\_methods}
      \item Generates intermediate variables using \texttt{generate\_vars}
      \item Validates chain breaks using \texttt{\_validate\_chain\_break}
      \item Preserves code formatting using \texttt{\_preserve\_indentation}
      \item Reconstructs code with intermediate assignments
    \end{itemize}
  \item \textbf{Output}: Modified AST
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{identify\_chains(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes AST for message chain patterns using \texttt{\_analyze\_chain\_complexity}
  \item \textbf{Output}: List of identified chains
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{extract\_methods(chain: Chain)}}
\begin{itemize}
  \item \textbf{Transition}: Extracts individual method calls from chain using \texttt{\_preserve\_indentation}
  \item \textbf{Output}: List of method call strings
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{generate\_vars(methods: List[str])}}
\begin{itemize}
  \item \textbf{Transition}: Creates unique variable names using \texttt{\_generate\_unique\_name}
  \item \textbf{Output}: List of variable names
  \item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_analyze\_chain\_complexity(chain: Chain)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes the length and complexity of method call chains
  \item \textbf{Output}: Integer representing chain complexity
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_preserve\_indentation(line: str)}}
\begin{itemize}
  \item \textbf{Transition}: Extracts and preserves the indentation level of code lines
  \item \textbf{Output}: String containing the indentation spaces
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_validate\_chain\_break(original: str, parts: List[str])}}
\begin{itemize}
  \item \textbf{Transition}: Verifies that breaking the chain preserves functionality
  \item \textbf{Output}: Boolean indicating if chain break is valid
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_generate\_unique\_name(base: str)}}
\begin{itemize}
  \item \textbf{Transition}: Creates a unique variable name based on the base string
  \item \textbf{Output}: String containing unique variable name
  \item \textbf{Exception}: None
\end{itemize}

~\newpage

\section{MIS of LongLambdaFunctionRefactorer} \label{mis:LLF}

\texttt{LongLambdaFunctionRefactorer}

\subsection{Module}
LongLambdaFunctionRefactorer is a module that refactors 
long lambda functions in Python code by converting them into normal functions. 
This improves code readability, maintainability, and performance, while reducing potential energy consumption.

\subsection{Uses}

\texttt{BaseRefactorer}

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
\texttt{LongLambdaFunctionRefactorer} & \texttt{output\_dir: Path} & \texttt{self} & None \\\hline
\texttt{refactor} & \texttt{file\_path: Path, smell: Smell, initial\_emissions: $\mathbb{R}$} & None & \texttt{IOError} \\\hline
\texttt{identify\_lambdas} & \texttt{node: AST} & \texttt{List[Lambda]} & None \\\hline
\texttt{extract\_lambda\_components} & \texttt{lambda\_node: Lambda} & \texttt{(List[str], str)} & None \\\hline
\texttt{generate\_function\_name} & \texttt{lambda\_body: str} & \texttt{str} & None \\\hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \textbf{lambda\_registry}: Dictionary mapping lambda nodes to their locations
  \item \textbf{function\_counter}: Counter for generating unique function names
  \item \textbf{scope\_stack}: Stack tracking current scope for function placement
\end{itemize}

\subsubsection{Environment Variables}
Inherits from \texttt{BaseRefactorer}

\subsubsection{Assumptions}
\begin{itemize}
  \item Input code contains valid Python syntax
  \item Lambda functions are properly defined
  \item Generated function names do not conflict with existing ones
  \item Scope information is correctly maintained
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{LongLambdaFunctionRefactorer(output\_dir: Path)}}
\begin{itemize}
  \item \textbf{Transition}: 
    \begin{itemize}
      \item Initializes base refactorer
      \item Sets up lambda registry
      \item Initializes function counter
      \item Configures scope tracking
    \end{itemize}
  \item \textbf{Output}: \texttt{self}
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{refactor(file\_path: Path, smell: Smell, initial\_emissions: $\mathbb{R}$)}}
\begin{itemize}
  \item \textbf{Transition}:
    \begin{itemize}
      \item Reads source file
      \item Identifies long lambda functions
      \item Converts lambdas to named functions
      \item Validates transformation
      \item Writes refactored code if valid
    \end{itemize}
  \item \textbf{Output}: None
  \item \textbf{Exception}: \texttt{IOError} if file operations fail
\end{itemize}

\paragraph{\texttt{identify\_lambdas(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes AST node for lambda function definitions
  \item \textbf{Output}: List of identified lambda nodes
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{extract\_lambda\_components(lambda\_node: Lambda)}}
\begin{itemize}
  \item \textbf{Transition}: Extracts parameters and body from lambda function
  \item \textbf{Output}: Tuple of parameter list and body string
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{generate\_function\_name(lambda\_body: str)}}
\begin{itemize}
  \item \textbf{Transition}: Creates descriptive name based on lambda body
  \item \textbf{Output}: Generated function name
  \item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_analyze\_lambda\_complexity(node: Lambda)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes lambda function complexity based on length and nesting
  \item \textbf{Output}: Integer representing complexity score
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_find\_insertion\_point(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Determines optimal location for new function definition
  \item \textbf{Output}: AST node indicating insertion point
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_validate\_scope(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Verifies scope compatibility for function placement
  \item \textbf{Output}: Boolean indicating valid scope
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_create\_function\_def(name: str, params: List[str], body: str)}}
\begin{itemize}
  \item \textbf{Transition}: Generates AST node for new function definition
  \item \textbf{Output}: FunctionDef AST node
  \item \textbf{Exception}: None
\end{itemize}

~\newpage

\section{MIS of LongParameterListRefactorer} \label{Module} 

\texttt{LongParameterListRefactorer}

\subsection{Module}

LongParameterListRefactorer is a module that identifies and refactors functions or methods with long parameter lists(detected beyond configured threshold) in Python code. The refactoring aims to improve code readability, maintainability, and energy efficiency by encapsulating related parameters into objects and removing unused ones.

\subsection{Uses}

\begin{itemize}
  \item Uses \texttt{Smell} interface for data access
  \item Inherits from \texttt{BaseRefactorer}
  \item Inherits from Python's \texttt{ast} module's \texttt{NodeTransformer}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{LongParameterListRefactorer} & \texttt{output\_dir: Path} & \texttt{self} & None \\
\hline
\texttt{refactor} & \texttt{file\_path: Path, pylint\_smell: Smell, initial\_emissions: $\mathbb{R}$} & None & \texttt{TypeError}, \texttt{IOError} \\
\hline
\end{tabularx}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}

\begin{itemize}
  \item Input files are valid Python scripts.
  \item Smells identified by \texttt{pylint\_smell} include valid line numbers.
  \item Refactored code must pass the provided test suite.
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{LongParameterListRefactorer(output\_dir: Path)}}
\begin{itemize}
\item \textbf{Transition}: Initializes the refactorer with the specified output directory.
\item \textbf{Output}: \texttt{self}.
\item \textbf{Exception}: None.
\end{itemize}

\paragraph{\texttt{refactor(file\_path: Path, pylint\_smell: Smell, initial\_emissions: $\mathbb{R}$)}}
\begin{itemize}
  \item \textbf{Transition}:
  \begin{enumerate}
  \item Reads the file at \texttt{file\_path} and locates the target function using \texttt{pylint\_smell}.
  \item Analyzes function body using \texttt{get\_used\_parameters} to identify used parameters and remove unused ones.
  \item For remaining parameters that exceed the configured limit:
    \begin{itemize}
      \item Groups parameters using \texttt{classify\_parameters}
      \item Creates parameter classes using \texttt{create\_parameter\_object\_class}
      \item Updates function signature using \texttt{update\_function\_signature}
      \item Updates parameter usages using \texttt{update\_parameter\_usages}
      \item Updates function calls using \texttt{update\_function\_calls}
    \end{itemize}
  \item Writes the refactored code to a temporary file.
  \end{enumerate}
  \item \textbf{Output}: None. Refactored file is saved if improvements are validated. 
  \item \textbf{Exception}: Raises \texttt{IOError} if input file cannot be read. Raises \texttt{TypeError} if source file cannot be parsed into an AST.
  \end{itemize}

\subsubsection{Local Functions}

\begin{enumerate}
  \item \texttt{get\_used\_parameters(function\_node: ast.FunctionDef, params: list[str]) -> list[str]}: 
  \begin{itemize}
    \item \textbf{transition}: Identifies parameters used within the function body.
    \item \textbf{output}: List of names of parameters that are actually used in the function.
    \item \textbf{exception}: None
  \end{itemize}
  \item \texttt{get\_parameters\_with\_default\_value(params: list[ast.Param]) -> key-value pairs}: 
  \begin{itemize}
    \item \textbf{transition}: Maps parameter names to their default values .
    \item \textbf{output}: Key-value pairs mapping parameter names to their default values.
    \item \textbf{exception}: None
  \end{itemize}
  \item \texttt{classify\_parameters(params: list[str]) -> key-value pairs}: 
  \begin{itemize}
    \item \textbf{transition}: Classifies parameters into \texttt{data} and \texttt{config} groups based on naming conventions.
    \item \textbf{output}: Key-value pairs with keys "data\_params" and "config\_params" mapping to lists of parameter names.
    \item \textbf{exception}: None
  \end{itemize}
  \item \texttt{create\_parameter\_object\_class(param\_names: list[str], default\_value\_params: key-value pairs, class\_name: str) -> ast.ClassDef}: 
  \begin{itemize}
    \item \textbf{transition}: Creates an AST class definition for encapsulating related parameters.
    \item \textbf{output}: AST ClassDef node representing the parameter object class.
    \item \textbf{exception}: None
  \end{itemize}
  \item \texttt{update\_function\_signature(function\_node: ast.FunctionDef, classified\_params: key-value pairs) -> ast.FunctionDef}:
  \begin{itemize}
    \item \textbf{transition}: Updates function signatures to use encapsulated parameter objects.
    \item \textbf{output}: Updated AST FunctionDef node with new parameter structure.
    \item \textbf{exception}: None
  \end{itemize}
  \item \texttt{update\_parameter\_usages(function\_node: ast.FunctionDef, classified\_params: key-value pairs) -> ast.FunctionDef}: 
  \begin{itemize}
    \item \textbf{transition}: Updates parameter references in function body to use encapsulated object attributes.
    \item \textbf{output}: Updated AST FunctionDef node with transformed parameter usages.
    \item \textbf{exception}: None
  \end{itemize}
  \item \texttt{update\_function\_calls(tree: ast.Module, function\_node: ast.FunctionDef, used\_params: list[str], classified\_params: key-value pairs, classified\_param\_names: tuple[str, str], enclosing\_class\_name: str) -> ast.Module}: 
  \begin{itemize}
    \item \textbf{transition}: Updates all calls to the refactored function to use new parameter structure.
    \item \textbf{output}: Updated AST Module node with transformed function calls.
    \item \textbf{exception}: None
  \end{itemize}
  \end{enumerate}

  \section{MIS of UseListAccumulationRefactorer} \label{mis:ListAccum}

  \texttt{UseListAccumulationRefactorer}
  
  \subsection{Module}
  
  The \texttt{UseListAccumulationRefactorer} module identifies and refactors 
  string concatenations in loops in Python code to improve the performance and energy efficiency of the software. It specifically handles these concatenations by, instead, adding the string for each iteration to a list that is then converted to a string, ensuring proper refactoring while maintaining the original functionality.
  
  \subsection{Uses}
  \begin{itemize}
  \item Uses \texttt{Smell} interface for data access
  \item Inherits from \texttt{BaseRefactorer}
  \item Uses \texttt{astroid} library for AST manipulation
  \end{itemize}
  
  \subsection{Syntax}
  \noindent
  \textbf{Exported Constants}: None
  
  \noindent
  \textbf{Exported Access Programs}:
  
  \begin{tabularx}{\linewidth}{|
      l|
      >{\raggedright\arraybackslash}X|
      l|
      l|}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    \texttt{UseListAccumulationRefactorer} & \texttt{output\_dir: Path} & \texttt{self} & None \\
    \hline
    \texttt{refactor} & \texttt{file\_path: Path, pylint\_smell: Smell, initial\_emissions: $\mathbb{R}$} & None & \texttt{TypeError}, \texttt{IOError} \\
    \hline
  \end{tabularx}
  
  \subsection{Semantics}
  
  \subsubsection{State Variables}
  \begin{itemize}
  \item \texttt{target\_lines: list[int]}: Line numbers requiring refactoring
  \item \texttt{assign\_var: str}: Target concatenation variable name
  \item \texttt{target\_node: NodeNG}: AST node of concatenation target
  \item \texttt{last\_assign\_node: Assign|AugAssign}: Last variable assignment before loop
  \item \texttt{concat\_nodes: list[Assign|AugAssign]}: Detected concatenation nodes
  \item \texttt{reassignments: list[Assign]}: Variable reassignments in loop scope
  \item \texttt{outer\_loop: For|While}: Outermost loop containing concatenations
  \end{itemize}
  
  \subsubsection{Environment Variables}
  None
  
  \subsubsection{Assumptions}
  \begin{itemize}
  \item Input files contain valid Python syntax
  \item Smell detection provides valid line numbers and variable names
  \end{itemize}
  
  \subsubsection{Access Routine Semantics}
  
  \paragraph{\texttt{UseListAccumulationRefactorer(output\_dir: Path)}}
  \begin{itemize}
  \item \textbf{Transition}: Initializes refactorer with output directory
  \item \textbf{Output}: \texttt{self}
  \item \textbf{Exception}: None
  \end{itemize}
  
  \paragraph{\texttt{refactor(file\_path: Path, pylint\_smell: Smell, initial\_emissions: 
  R
  R)}}
  \begin{itemize}
  \item \textbf{Transition}:
  \begin{itemize}
  \item Parses code using \texttt{\_visit} pattern for AST traversal
  \item Identifies concatenations with \texttt{\_find\_reassignments}
  \item Determines scope via \texttt{\_find\_scope} and \texttt{\_find\_last\_assignment}
  \item Generates temp names with \texttt{\_generate\_temp\_list\_name}
  \item Modifies code using \texttt{\_add\_node\_to\_body}
  \item Validates transformations before writing to refactored file
  \end{itemize}
  \item \textbf{Output}: None
  \item \textbf{Exception}:
  \begin{itemize}
  \item \texttt{IOError}: File read/write failures
  \item \texttt{TypeError}: AST parsing errors
  \end{itemize}
  \end{itemize}
  
  \subsubsection{Local Functions}
  
  \paragraph{\texttt{\_visit(node: NodeNG)}}
  \begin{itemize}
  \item \textbf{Transition}: Collects concatenation nodes and loop structures
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
  \end{itemize}
  
  \paragraph{\texttt{\_find\_reassignments()}}
  \begin{itemize}
  \item \textbf{Transition}: Finds variable reassignments in loop scope
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
  \end{itemize}
  
  \paragraph{\texttt{\_find\_last\_assignment(scope: NodeNG)}}
  \begin{itemize}
  \item \textbf{Transition}: Locates final variable assignment before loop
  \item \textbf{Output}: None
  \item \textbf{Exception}: Raises \texttt{TypeError} for invalid scope
  \end{itemize}
  
  \paragraph{\texttt{\_find\_scope()}}
  \begin{itemize}
  \item \textbf{Transition}: Determines insertion point for list initialization
  \item \textbf{Output}: None
  \item \textbf{Exception}: Requires \texttt{concat\_nodes} to be populated
  \end{itemize}
  
  \paragraph{\texttt{\_generate\_temp\_list\_name()}}
  \begin{itemize}
  \item \textbf{Transition}: Creates unique list name for complex targets
  \item \textbf{Output}: Returns generated name string
  \item \textbf{Exception}: Raises \texttt{TypeError} for unsupported nodes
  \end{itemize}
  
  \paragraph{\texttt{\_add\_node\_to\_body(code\_file: str, nodes\_to\_change: list[tuple])}}
  \begin{itemize}
  \item \textbf{Transition}:
  \begin{itemize}
  \item Replaces concatenations with list operations
  \item Adds join() call and list initialization
  \end{itemize}
  \item \textbf{Output}: Returns modified source code
  \item \textbf{Exception}: Requires valid node references
  \end{itemize}

  
\newpage

\section{MIS of MakeMethodStaticRefactorer} \label{mis:MakeStatic}

\texttt{MakeStaticRefactorer}

\subsection{Module}

The \texttt{MakeStaticRefactorer} module identifies and refactors 
class methods that don't make use of their instance attributes to improve the readability, performance and energy efficiency of the software. It specifically handles these methods by turning them into static functions and ensuring any calls to this method use the proper calling syntax. This ensures proper refactoring while maintaining the original functionality.

\subsection{Uses}

\texttt{BaseRefactorer}

\subsection{Syntax}

\noindent
\textbf{Exported Constants}: None\\

\noindent
\textbf{Exported Access Programs}:\\

\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
\texttt{apply\_transformation} & \texttt{node: AST} & \texttt{AST} & None \\\hline
\texttt{identify\_methods} & \texttt{node: AST} & \texttt{List[Method]} & None \\\hline
\texttt{analyze\_method\_usage} & \texttt{method: Method} & \texttt{bool} & None \\\hline
\texttt{transform\_to\_static} & \texttt{method: Method} & \texttt{Method} & None \\\hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{class\_hierarchy}: Dictionary mapping classes to their inheritance tree
  \item \texttt{method\_registry}: Dictionary mapping methods to their usage patterns
  \item \texttt{static\_candidates}: Set of methods eligible for static conversion
\end{itemize}

\subsubsection{Environment Variables}
Inherits from \texttt{BaseRefactorer}

\subsubsection{Assumptions}
\begin{itemize}
  \item Class inheritance hierarchies are well-defined
  \item Method definitions are complete and valid
  \item No dynamic method creation or modification
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{apply\_transformation(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}:
    \begin{itemize}
      \item Identifies candidate methods using \texttt{identify\_methods}
      \item Analyzes each method using \texttt{analyze\_method\_usage}
      \item Transforms eligible methods using \texttt{transform\_to\_static}
      \item Updates method calls using \texttt{\_update\_method\_calls}
      \item Validates transformation using \texttt{\_validate\_transformation}
      \item Reconstructs code with static methods
    \end{itemize}
  \item \textbf{Output}: Modified AST
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{identify\_methods(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes AST for instance methods using \texttt{\_build\_class\_hierarchy}
  \item \textbf{Output}: List of identified methods
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{analyze\_method\_usage(method: Method)}}
\begin{itemize}
  \item \textbf{Transition}: Evaluates method for static conversion using \texttt{\_check\_inheritance\_safety}
  \item \textbf{Output}: Boolean indicating if method can be made static
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{transform\_to\_static(method: Method)}}
\begin{itemize}
  \item \textbf{Transition}: Converts instance method to static using \texttt{\_update\_method\_calls} and validates using \texttt{\_validate\_transformation}
  \item \textbf{Output}: Transformed method
  \item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_build\_class\_hierarchy(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes class definitions and builds inheritance relationships
  \item \textbf{Output}: Dictionary mapping classes to their parent classes
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_check\_inheritance\_safety(method: Method)}}
\begin{itemize}
  \item \textbf{Transition}: Verifies method can be safely made static across inheritance chain
  \item \textbf{Output}: Boolean indicating if transformation is safe
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_update\_method\_calls(old\_method: str, new\_method: str)}}
\begin{itemize}
  \item \textbf{Transition}: Updates all call sites to use static method syntax
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_validate\_transformation(method: Method)}}
\begin{itemize}
  \item \textbf{Transition}: Verifies the static method transformation maintains functionality
  \item \textbf{Output}: Boolean indicating if transformation is valid
  \item \textbf{Exception}: None
\end{itemize}

\newpage  


\section{MIS of LongElementChainRefactorer} \label{mis:lec}

\texttt{LongElementChainRefactorer}

\subsection{Module}

LongElementChainRefactorer is a module that refactors long element chains, specifically focusing on flattening nested dictionaries to improve readability, maintainability, and energy efficiency. The module uses a recursive flattening strategy while caching previously seen patterns for optimization.

\subsection{Uses}

\texttt{BaseRefactorer}

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
\texttt{apply\_transformation} & \texttt{node: AST} & \texttt{AST} & None \\\hline
\texttt{identify\_nested\_dicts} & \texttt{node: AST} & \texttt{List[Dict]} & None \\\hline
\texttt{flatten\_dict} & \texttt{dict\_node: Dict} & \texttt{Dict} & None \\\hline
\texttt{update\_access\_calls} & \texttt{old\_path: str, new\_path: str} & None & None \\\hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \textbf{dict\_patterns}: Dictionary mapping access patterns to their flattened forms
  \item \textbf{flattened\_keys}: Set of generated flattened key names
  \item \textbf{reference\_map}: Mapping of original to flattened dictionary paths
\end{itemize}

\subsubsection{Environment Variables}
Inherits from \texttt{BaseRefactorer}

\subsubsection{Assumptions}
\begin{itemize}
  \item Dictionary keys are valid Python identifiers
  \item No key name conflicts in flattened structure
  \item Dictionary access patterns are consistent
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{apply\_transformation(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}:
    \begin{itemize}
      \item Identifies nested dictionaries using \texttt{identify\_nested\_dicts}
      \item Flattens each dictionary using \texttt{flatten\_dict}
      \item Updates access patterns using \texttt{update\_access\_calls}
      \item Updates code references using \texttt{\_update\_references}
      \item Validates dictionary access using \texttt{\_validate\_dict\_access}
      \item Reconstructs code with flattened structure
    \end{itemize}
  \item \textbf{Output}: Modified AST
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{identify\_nested\_dicts(node: AST)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes AST for nested dictionary patterns using \texttt{\_analyze\_dict\_complexity}
  \item \textbf{Output}: List of identified dictionaries
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{flatten\_dict(dict\_node: Dict)}}
\begin{itemize}
  \item \textbf{Transition}: Creates flattened dictionary structure using \texttt{\_generate\_flat\_key}
  \item \textbf{Output}: Flattened dictionary
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{update\_access\_calls(old\_path: str, new\_path: str)}}
\begin{itemize}
  \item \textbf{Transition}: Updates dictionary access patterns using \texttt{\_validate\_dict\_access} and \texttt{\_update\_references}
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_analyze\_dict\_complexity(node: Dict)}}
\begin{itemize}
  \item \textbf{Transition}: Analyzes the nesting depth and structure of dictionary nodes
  \item \textbf{Output}: Integer representing complexity score
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_generate\_flat\_key(path: List[str])}}
\begin{itemize}
  \item \textbf{Transition}: Concatenates path components into a flattened key name
  \item \textbf{Output}: String representing the flattened key
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_validate\_dict\_access(path: str)}}
\begin{itemize}
  \item \textbf{Transition}: Checks if dictionary access path is valid and follows conventions
  \item \textbf{Output}: Boolean indicating validity
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_update\_references(old\_ref: str, new\_ref: str)}}
\begin{itemize}
  \item \textbf{Transition}: Updates all references to the old dictionary path with the new flattened path
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
\end{itemize}

\section{MIS of Measurements Module} \label{mis:measure}

\texttt{Measurements}

\subsection{Module}

The MeasurementsModule is a module designed to measure and track the carbon emissions generated by executing scripts. By leveraging the CodeCarbon library, it allows developers to assess the environmental impact of their code execution. The module runs a specified Python file, tracks the associated carbon emissions during the execution, and logs the results for further analysis. It provides functionality for measuring, logging, and extracting emissions data in a structured manner to help improve energy efficiency in software development.


\subsection{Uses}

\begin{itemize}
\item Uses \texttt{CodeCarbon} library for track energy consumption
\item Uses \texttt{TemporaryDirectory} to store temporary files
\item Inherits from \texttt{BaseEnergyMeter}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\texttt{Measurements} & \texttt{output\_dir: Path} & \texttt{self} & None \\
\hline
\texttt{measure\_energy} & \texttt{None} & None & CalledProcessError and FileReading exceptions \\
\hline
\end{tabularx}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
\item \textbf{emissions\_data}: Stores the emissions data extracted from the CSV file generated by CodeCarbon. It is populated after the energy measurement process completes successfully. The value is either a dictionary containing the last row of emissions data or \texttt{None} if no data was extracted due to an error.
\item \textbf{emissions}: Raw emissions object from CodeCarbon tracker
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}

\begin{itemize}
\item The file at \texttt{file\_path} is a valid Python script.
\item The CodeCarbon tool is properly installed and configured.
\item The \texttt{EmissionsTracker} can successfully execute the Python script specified by \texttt{file\_path}.
\item The emissions data is captured in a CSV format and can be extracted correctly.
\item The temporary directories are correctly set up and accessible during execution.
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{Measurements(output\_dir: Path)}}
\begin{itemize}
\item \textbf{Transition}: Initializes the energy meter with empty emissions data
\item \textbf{Output}: \texttt{self}
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{measure\_energy()}}
\begin{itemize}
\item \textbf{Transition}:
\begin{itemize}
\item Logs the start of the energy measurement process
\item Creates isolated temporary directory using \texttt{TemporaryDirectory}
\item Configures system temp directories through environment variables
\item Initializes CodeCarbon \texttt{EmissionsTracker} in process mode
\item Runs the script specified by file path and captures the output
\item Stops tracker and captures raw emissions data
\item Validates emissions CSV creation
\item Parses results using \texttt{extract\_emissions\_csv}
\end{itemize}
\item \textbf{Output}:
\begin{itemize}
\item Updates \texttt{emissions} with tracker results
\item Populates \texttt{emissions\_data} with parsed metrics
\end{itemize}
\item \textbf{Exception}:
\begin{itemize}
\item \texttt{CalledProcessError}: If script execution fails
\item \texttt{FileNotFoundError}: If emissions CSV is missing
\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{extract\_emissions\_csv(csv\_file\_path: Path)}}
\begin{itemize}
  \item \textbf{Transition}:
  \begin{itemize}
    \item Attempts to read CSV file using pandas
    \item Extracts last measurement record
    \item Converts DataFrame row to dictionary
  \end{itemize}
  \item \textbf{Output}: Returns dictionary of metrics or \texttt{None} on error
  \item \textbf{Exception}: Logs pandas read errors but does not propagate them
\end{itemize}
  
  
\newpage
\section{MIS of PylintAnalyzer} \label{mis:PylintAnalyzer}

\texttt{PylintAnalyzer}

\subsection{Module}

The \texttt{PylintAnalyzer} module performs static code analysis on Python files using Pylint, with additional custom checks for detecting specific code smells. It outputs detected smells in a structured format for further processing.

\subsection{Uses}
\begin{itemize}
\item Uses Python's \texttt{pylint} library for code analysis
\item Uses \texttt{ast} module for parsing and analyzing abstract syntax trees
\item Uses \texttt{astor} library for converting AST nodes back to source code
\item Integrates with custom checkers, including \texttt{StringConcatInLoopChecker}
\item Accesses configuration settings from \texttt{analyzers\_config}
\end{itemize}

\subsection{Syntax}
\noindent
\textbf{Exported Constants}: None

\noindent
\textbf{Exported Access Programs}:\\
{\footnotesize
\begin{tabularx}{\linewidth}{|
    l|
    >{\raggedright\arraybackslash}X|
    l|
    l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
  \texttt{PylintAnalyzer} & \texttt{file\_path: Path, source\_code: Module} & \texttt{self} & None \\
  \hline
  \texttt{build\_pylint\_options} & None & \texttt{list[str]} & None \\
  \hline
  \texttt{analyze} & None & None & \texttt{JSONDecodeError}, \texttt{Exception} \\
  \hline
  \texttt{configure\_smells} & None & None & None \\
  \hline
  \texttt{filter\_for\_one\_code\_smell} & \texttt{pylint\_results: list[Smell], code: str} & \texttt{list[Smell]} & None \\
  \hline
\end{tabularx}
}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{file\_path: Path}: The path to the Python file being analyzed
\item \texttt{source\_code: Module}: The parsed abstract syntax tree of the source file
\item \texttt{smells\_data: list[dict]}: List of detected code smells in dictionary format
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item The input file is valid Python code and can be parsed into an AST
\item Configuration settings (extra Pylint options, custom smell definitions) are valid
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{PylintAnalyzer(file\_path: Path, source\_code: Module)}}
\begin{itemize}
\item \textbf{Transition}: Initializes analyzer with file path and AST
\item \textbf{Output}: \texttt{self}
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{build\_pylint\_options()}}
\begin{itemize}
\item \textbf{Transition}: Constructs Pylint options list from config
\item \textbf{Output}: List of option strings
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{analyze()}}
\begin{itemize}
\item \textbf{Transition}:
\begin{itemize}
\item Executes Pylint analysis with custom checks using the local detect functions
\item Populates \texttt{smells\_data} with results and uses \texttt{parse\_line}
\end{itemize}
\item \textbf{Output}: None
\item \textbf{Exception}:
\begin{itemize}
\item \texttt{JSONDecodeError} for invalid Pylint output
\item \texttt{Exception} for general runtime errors
\end{itemize}
\end{itemize}

\paragraph{\texttt{configure\_smells()}}
\begin{itemize}
\item \textbf{Transition}: Filters \texttt{smells\_data} to configured smells
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{filter\_for\_one\_code\_smell(pylint\_results: list[Smell], code: str)}}
\begin{itemize}
\item \textbf{Transition}: Filters results by smell type code
\item \textbf{Output}: Filtered list of smells
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_detect\_long\_message\_chain(threshold?: int)}}
\begin{itemize}
  \item \textbf{Transition}: Identifies method chains exceeding length threshold
  \item \textbf{Output}: List of long chain smells
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_detect\_long\_lambda\_expression(threshold\_length?: int, threshold\_count?: int)}}
\begin{itemize}
  \item \textbf{Transition}: Detects oversized lambda expressions
  \item \textbf{Output}: List of lambda smells
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_detect\_long\_element\_chain(threshold?: int)}}
\begin{itemize}
  \item \textbf{Transition}: Finds long dictionary access chains
  \item \textbf{Output}: List of element chain smells
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_detect\_repeated\_calls(threshold?: int)}}
\begin{itemize}
  \item \textbf{Transition}: Identifies excessive repeated calls
  \item \textbf{Output}: List of repetition smells
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_parse\_line(file\_path: Path, line: int)}}
\begin{itemize}
  \item \textbf{Transition}: Extracts AST node from specific line
  \item \textbf{Output}: Parsed AST node
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_get\_lambda\_code(lambda\_node: Lambda)}}
\begin{itemize}
  \item \textbf{Transition}: Converts lambda node to source code
  \item \textbf{Output}: String representation of lambda
  \item \textbf{Exception}: None
\end{itemize}

\newpage
\section{MIS of UseAGeneratorRefactorer} \label{mis:UseGen}

\texttt{UseAGeneratorRefactorer}

\subsection{Module}

The \texttt{UseAGeneratorRefactorer} module identifies and refactors 
unnecessary list comprehensions in Python code by converting them to generator expressions. This refactoring improves energy efficiency while maintaining the original functionality.

\subsection{Uses}
\begin{itemize}
\item Uses \texttt{Smell} interface for data access
\item Inherits from \texttt{BaseRefactorer}
\item Uses Python's \texttt{ast} module for parsing and manipulating abstract syntax trees
\end{itemize}

\subsection{Syntax}
\noindent
\textbf{Exported Constants}: None


\noindent
\textbf{Exported Access Programs}:\\
\begin{tabularx}{\linewidth}{|
    l|
    >{\raggedright\arraybackslash}X|
    l|
    l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
  \texttt{UseAGeneratorRefactorer} & \texttt{output\_dir: Path} & \texttt{self} & None \\
  \hline
  \texttt{refactor} & \texttt{file\_path: Path, pylint\_smell: Smell, initial\_emissions: $\mathbb{R}$} & None & \texttt{IOError}, \texttt{TypeError} \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{temp\_dir: Path}: Directory path for storing refactored files
\item \texttt{output\_dir: Path}: Directory path for saving final refactored code
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item The input file contains valid Python syntax
\item \texttt{pylint\_smell} provides valid line/column locations
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{UseAGeneratorRefactorer(output\_dir: Path)}}
\begin{itemize}
\item \textbf{Transition}: Initializes temporary directory within output directory
\item \textbf{Output}: \texttt{self}
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{refactor(file\_path: Path, pylint\_smell: Smell, initial\_emissions: 
R
R)}}
\begin{itemize}
\item \textbf{Transition}:
\begin{itemize}
\item Reads source code using \texttt{ListCompInAnyAllTransformer} metadata
\item Applies AST transformation via \texttt{\_replace\_node} for node substitution
\item Uses \texttt{leave\_Call} in transformer to identify replacement targets
\item Validates and writes modified code using generator expressions
\end{itemize}
\item \textbf{Output}: None
\item \textbf{Exception}:
\begin{itemize}
\item \texttt{IOError}: File read/write failures
\item \texttt{TypeError}: CST parsing errors
\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_replace\_node(tree: Module, old\_node: ListComp, new\_node: GeneratorExp)}}
\begin{itemize}
\item \textbf{Transition}: Replaces list comprehension node with generator expression
\item \textbf{Output}: Modified AST
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{ListCompInAnyAllTransformer}}
\begin{itemize}
\item \textbf{Transition}: Custom CST transformer that identifies and converts list comprehensions in any()/all() calls
\item \textbf{Output}: Modified syntax tree
\item \textbf{Exception}: None
\end{itemize}

\newpage

\section{MIS of CacheRepeatedCallsRefactorer} \label{mis:CacheCalls}

\texttt{CacheRepeatedCallsRefactorer}

\subsection{Module}
The \texttt{CacheRepeatedCallsRefactorer} identifies and caches repeated function calls using temporary variables to improve performance and energy efficiency while preserving functionality.

\subsection{Uses}
\begin{itemize}
\item Uses \texttt{Smell} interface for data access
\item Inherits from \texttt{BaseRefactorer}
\item Uses Python's \texttt{ast} module for AST manipulation
\end{itemize}

\subsection{Syntax}
\noindent
\textbf{Exported Constants}: None

\noindent
\textbf{Exported Access Programs}:\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\\hline
  \texttt{CacheRepeatedCallsRefactorer} & \texttt{output\_dir: Path} & \texttt{self} & None \\
  \hline
  \texttt{refactor} & \texttt{file\_path: Path, pylint\_smell: Smell, initial\_emissions: $\mathbb{R}$} & None & \texttt{IOError}, \texttt{TypeError} \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{cached\_var\_name: str}: Name of the temporary variable used for caching.
  \item \texttt{target\_line: int}: Line number where refactoring is applied.
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item Input files contain valid Python syntax
\item Smell detection provides valid call patterns
\item Repeated calls have no side effects
\end{itemize}

\subsubsection{Access Routine Semantics}

\paragraph{\texttt{CacheRepeatedCallsRefactorer(output\_dir: Path)}}
\begin{itemize}
\item \textbf{Transition}: Initializes temp directory
\item \textbf{Output}: \texttt{self}
\item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{refactor(file\_path: Path, smell: CRCSmell, ...)}}
\begin{itemize}
\item \textbf{Transition}:
\begin{itemize}
\item Generates cache name via \texttt{\_extract\_function\_name}
\item Locates insertion point with \texttt{\_find\_insert\_line}
\item Determines indentation via \texttt{\_get\_indentation}
\item Modifies calls using \texttt{\_replace\_call\_in\_line}
\item Validates scope with \texttt{\_find\_valid\_parent}
\end{itemize}
\item \textbf{Output}: None
\item \textbf{Exception}:
\begin{itemize}
\item \texttt{IOError}: File access failures
\item \texttt{TypeError}: Invalid AST structure
\end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_extract\_function\_name(call\_string: str)}}
\begin{itemize}
  \item \textbf{Transition}: Extracts function name from call expression
  \item \textbf{Output}: String containing function name
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_get\_indentation(lines: list[str], line\_number: int)}}
\begin{itemize}
  \item \textbf{Transition}: Calculates whitespace for code insertion
  \item \textbf{Output}: Indentation string
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_replace\_call\_in\_line(line: str, call\_string: str, cached\_var\_name: str)}}
\begin{itemize}
  \item \textbf{Transition}: Replaces function calls with cache variable
  \item \textbf{Output}: Modified source line
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_find\_valid\_parent(tree: ast.Module)}}
\begin{itemize}
  \item \textbf{Transition}: Locates common parent for all call instances
  \item \textbf{Output}: Parent AST node or None
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_find\_insert\_line(parent\_node: ast.AST)}}
\begin{itemize}
  \item \textbf{Transition}: Determines optimal insertion point
  \item \textbf{Output}: Line number for cache assignment
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_line\_in\_node\_body(node: ast.AST, line: int)}}
\begin{itemize}
  \item \textbf{Transition}: Verifies line belongs to node body
  \item \textbf{Output}: Boolean existence check
  \item \textbf{Exception}: None
\end{itemize}

\newpage

\section{MIS of PluginInitiator}

\subsection{Module}
\texttt{PluginInitiator} is a module that initialises the VS Code plugin and registers commands for VS Code Plugin.

\subsection{Uses}
\begin{itemize}
    \item \texttt{SmellDetector} to register and manage smell detection functionality.
    \item \texttt{RefactorManager} to register and manage refactoring operations.
    \item \texttt{FilterManager} to register and manage smell filtering operations.
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} 
\begin{itemize}
    \item \texttt{ecoOutput}: VS Code OutputChannel for logging and information display
\end{itemize}

\noindent \textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    \texttt{activate} & \texttt{context: vscode.ExtensionContext} & void & None \\
    \hline
    \texttt{deactivate} & None & void & None \\
    \hline
    \texttt{isSmellLintingEnabled} & None & boolean & None \\
    \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{smellLintingEnabled: boolean} - Tracks if smell linting is enabled
    \item \texttt{backendLogManager: LogManager} - Manages backend logging
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item VS Code extension context
    \item Workspace configuration state
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The plugin is correctly loaded in VS Code
    \item VS Code APIs are available and accessible
    \item Required modules (SmellDetector, RefactorManager, FilterManager) are properly initialised
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\texttt{activate(context: vscode.ExtensionContext)}
\begin{itemize}
    \item \textbf{Transition}: 
    \begin{itemize}
        \item Initialises output channel for logging
        \item Initialises SmellDetector module
        \item Initialises RefactorManager module
        \item Initialises FilterManager module
        \item Sets up workspace configuration
        \item Registers plugin commands
    \end{itemize}
    \item \textbf{Output}: None
    \item \textbf{Exception}: None
\end{itemize}

\noindent\texttt{deactivate()}
\begin{itemize}
    \item \textbf{Transition}: Cleans up resources and stops background processes
    \item \textbf{Output}: None
    \item \textbf{Exception}: None
\end{itemize}

\noindent\texttt{isSmellLintingEnabled()}
\begin{itemize}
    \item \textbf{Transition}: Returns current state of smell linting
    \item \textbf{Output}: boolean indicating if smell linting is enabled
    \item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of BackendCommunicator}

\subsection{Module}
\texttt{BackendCommunicator} handles all communication between the plugin and the backend service. It sends requests for analysis or refactoring and receives results.

\subsection{Uses}
\begin{itemize}
    \item \texttt{EcoOptimizer} for executing backend service operations and health checks
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} 
\begin{itemize}
    \item \texttt{BASE\_URL}: string - Base URL for backend API endpoints
\end{itemize}

\noindent \textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\ 
    \hline
    \texttt{checkServerStatus} & None & Promise$<$void$>$ & Network Error \\
    \hline
    \texttt{initLogs} & \texttt{log\_dir: string} & Promise$<$boolean$>$ & Network Error \\
    \hline
    \texttt{fetchSmells} & \texttt{filePath: string, enabledSmells: Record$<$string, Record$<$string, number | string$>$$>$} &
    Promise$<$\{smells: Smell[], status: number\}$>$ & Network Error \\
    \hline
    \texttt{backendRefactor\allowbreak Smell} & \texttt{smell: Smell, workspacePath: string} & Promise$<$RefactoredData$>$ & Network Error \\
    \hline
    \texttt{backendRefactor\allowbreak SmellType} & \texttt{smell: Smell, workspacePath: string} & Promise$<$RefactoredData$>$ & Network Error \\
    \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{serverStatus: ServerStatusType} - Tracks the backend server's current status
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \texttt{SERVER\_URL: string} - Backend server URL from environment configuration
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item EcoOptimizer backend service is reachable and operational
    \item Network connection is available for API communication
    \item Valid workspace configuration exists for operations requiring paths
    \item Input files contain valid Python syntax
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\texttt{checkServerStatus()}
\begin{itemize}
    \item \textbf{Transition}: Verifies backend service availability and updates extension status
    \item \textbf{Output}: Promise resolving to void
    \item \textbf{Exception}: Logs network errors and updates server status to DOWN
\end{itemize}

\noindent\texttt{initLogs(log\_dir: string)}
\begin{itemize}
    \item \textbf{Transition}: Initialises and synchronises logs with the backend server
    \item \textbf{Output}: Promise$<$boolean$>$ indicating success or failure
    \item \textbf{Exception}: Logs initialisation errors and returns false
\end{itemize}

\noindent\texttt{fetchSmells(filePath: string, enabledSmells: Record)}
\begin{itemize}
    \item \textbf{Transition}: Analyses source code for code smells using backend detection service
    \item \textbf{Output}: Promise resolving to smell detection results and HTTP status
    \item \textbf{Exception}: Throws Error for network failures or invalid responses
\end{itemize}

\noindent\texttt{backendRefactorSmell(smell: Smell, workspacePath: string)}
\begin{itemize}
    \item \textbf{Transition}: Executes code refactoring for a specific detected smell pattern
    \item \textbf{Output}: Promise resolving to refactoring result data
    \item \textbf{Exception}: Throws Error for invalid workspace path or refactoring failures
\end{itemize}

\noindent\texttt{backendRefactorSmellType(smell: Smell, workspacePath: string)}
\begin{itemize}
    \item \textbf{Transition}: Refactors all smells of a specific type in a file
    \item \textbf{Output}: Promise resolving to refactoring result data
    \item \textbf{Exception}: Throws Error for invalid workspace path or refactoring failures
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of SmellDetector}

\subsection{Module}
\texttt{SmellDetector} analyses Python files for code smells and manages the detection workflow.

\subsection{Uses}
\begin{itemize}
\item \texttt{BackendCommunicator} for communicating with SourceCodeOptimizer
\item \texttt{CacheManager} for managing smell detection results
\item \texttt{FileHighlighter} for highlighting detected smells
\item \texttt{EventManager} for managing detection events
\item \texttt{HoverManager} for displaying smell information
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  \texttt{detectSmellsFile} & \texttt{filePath: string, smellsViewProvider: SmellsViewProvider, cacheManager: CacheManager} & Promise$<$void$>$ & Analysis Error \\
  \hline
  \texttt{detectSmellsFolder} & \texttt{folderPath: string, smellsViewProvider: SmellsViewProvider, cacheManager: CacheManager} & Promise$<$void$>$ & Analysis Error \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{serverStatus}: ServerStatusType - Current status of the backend server
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{enabledSmells}: Record$<$string, SmellConfig$>$ - Configuration of enabled smell detectors
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
\item Target files have valid Python syntax
\item Backend server is operational for non-cached analysis
\item At least one smell detector is enabled in settings
\item Valid workspace configuration exists
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{detectSmellsFile(filePath, smellsViewProvider, cacheManager)}
\begin{itemize}
\item \textbf{Transition}: Checks a Python file using \texttt{precheckAndMarkQueued()}, analyses it for code smells, updates cache and view
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: Throws error if analysis fails
\end{itemize}

\texttt{detectSmellsFolder(folderPath, smellsViewProvider, cacheManager)}
\begin{itemize}
\item \textbf{Transition}: Recursively analyzes Python files in directory, shows progress
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: Throws error if folder scanning or analysis fails
\end{itemize}

\subsubsection{Local Functions}
\texttt{precheckAndMarkQueued(filePath, smellsViewProvider, cacheManager)}
\begin{itemize}
\item \textbf{Transition}: Validates conditions before analysis and manages file status
\item \textbf{Output}: Promise$<$boolean$>$ indicating if analysis should proceed
\item \textbf{Exception}: None
\end{itemize}

\section{MIS of SmellRefactorer}

\subsection{Module}
\texttt{SmellRefactorer} applies a refactoring to a detected smell.

\subsection{Uses}
\begin{itemize}
\item \texttt{BackendCommunicator} for sending the smell data to Source Code Optimizer for refactoring.
\item \texttt{RefactorManager} for managing refactoring workflows.
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception}\\
  \hline
  \texttt{refactor} & {smell: Smell} & None & Invalid input \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Environment Variables}
None


\subsubsection{Assumptions}
\begin{itemize}
\item The smell data is valid and correctly identifies a refactorable issue.
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{refactor(smell: Smell)}
\begin{itemize}
\item \textbf{Transition}: Sends the smell data to the backend for refactoring and applies the changes in the editor.
\item \textbf{Output}: None.
\item \textbf{Exception}: Logs errors for invalid inputs or failed refactoring.
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of FileHighlighter}

\subsection{Module}
\texttt{FileHighlighter} is a module that manages highlighting of code regions in the VS Code editor.

\subsection{Uses}
\begin{itemize}
\item \texttt{ViewProvider} for managing editor decorations and visual updates
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\noindent \textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|p{5cm}|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{getInstance} & \texttt{cacheManager: CacheManager} & FileHighlighter & None \\ \hline
  \texttt{updateHighlightsFor \allowbreak VisibleEditors} & None & void & None \\ \hline
  \texttt{resetHighlights} & None & void & None \\ \hline
  \texttt{highlightSmells} & \texttt{editor: vscode.TextEditor} & void & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{instance}: FileHighlighter - Singleton instance of the highlighter
\item \texttt{decorations}: TextEditorDecorationType[] - Active editor decorations
\item \texttt{cacheManager}:  CacheManager - Reference to the cache manager
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{smellsColours}: Configuration for smell highlight colours
\item \texttt{useSingleColour}: Boolean flag for using single highlight colour
\item \texttt{singleHighlightColour}: Colour value for single highlight mode
\item \texttt{highlightStyle}: Style configuration for highlights
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
\item \texttt{CacheManager} is properly initialized
\item Valid configuration exists for highlight colours and styles
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{getInstance(cacheManager: CacheManager)}
\begin{itemize}
\item \textbf{Transition}: Creates or returns singleton instance of \texttt{FileHighlighter}
\item \textbf{Output}: \texttt{FileHighlighter} instance
\item \textbf{Exception}: None
\end{itemize}

\texttt{updateHighlightsForVisibleEditors()}
\begin{itemize}
\item \textbf{Transition}: Updates highlights for all visible Python files using \texttt{\_getDecoration} and \texttt{\_updateHighlightsForFile}
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{resetHighlights()}
\begin{itemize}
\item \textbf{Transition}: Removes all active highlights from editors
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{highlightSmells(editor: vscode.TextEditor)}
\begin{itemize}
\item \textbf{Transition}: Applies highlights for cached smells in the editor
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}

\paragraph{\texttt{\_getDecoration(colour, style)}}
\begin{itemize}
  \item \textbf{Transition}: Creates decoration type based on configuration
  \item \textbf{Output}: TextEditorDecorationType object
  \item \textbf{Exception}: None
\end{itemize}

\paragraph{\texttt{\_updateHighlightsForFile(filePath)}}
\begin{itemize}
  \item \textbf{Transition}: Updates highlights for a specific file
  \item \textbf{Output}: None
  \item \textbf{Exception}: None
\end{itemize}

\section{MIS of HoverManager}

\subsection{Module}
\texttt{HoverManager} manages hover effects to display contextual information.

\subsection{Uses}
\begin{itemize}
\item \texttt{ViewProvider} for managing hover display and updates
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{register} & \texttt{context: vscode.ExtensionContext} & void & None \\ \hline
  \texttt{provideHover} & \texttt{document: TextDocument, position: Position, token: CancellationToken} & ProviderResult$<$Hover$>$ & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{cacheManager}: CacheManager - Reference to the cache manager
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item VS Code editor is active with a Python file open
\item Valid hover position is provided
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{register(context: vscode.ExtensionContext)}
\begin{itemize}
\item \textbf{Transition}: Registers hover provider for Python files
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{provideHover(document, position, token)}
\begin{itemize}
\item \textbf{Transition}: Provides hover content with smell information
\item \textbf{Output}: Hover content or undefined
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of RefactorManager}

\subsection{Module}
\texttt{RefactorManager} manages the process of applying refactorings to detected smells.

\subsection{Uses}
\begin{itemize}
\item \texttt{EnergyMetrics} for tracking refactoring impact
\item \texttt{CacheManager} for managing refactoring state
\item \texttt{EventManager} for handling refactoring events
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\

\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{register} & \texttt{context: vscode.ExtensionContext} & void & None \\ \hline
  \texttt{provideHover} & \texttt{document: TextDocument, position: Position, token: CancellationToken} & ProviderResult$<$Hover$>$ & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{serverStatus}: ServerStatusType - Current status of the backend server
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
\item \texttt{WORKSPACE\_CONFIGURED\_PATH}: string - Path to workspace configuration
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
\item Backend server is operational
\item Valid workspace configuration exists
\item Smell data is valid and complete
\item Required view providers are initialized
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{refactor(smellsViewProvider, refactoringDetailsViewProvider, smell, context, isRefactorAllOfType)}
\begin{itemize}
\item \textbf{Transition}: Orchestrates complete refactoring workflow
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: Throws error for validation failures
\end{itemize}

\texttt{startRefactorSession(smell, refactoredData, refactoringDetailsViewProvider)}
\begin{itemize}
\item \textbf{Transition}: Initialises and manages refactoring session
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of CacheManager}

\subsection{Module}
\texttt{CacheManager} manages caching of detected smells and file states.

\subsection{Uses}
\begin{itemize}
\item \texttt{BackendCommunicator} for backend communication
\item \texttt{ViewProvider} for UI updates
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{setCachedSmells} & \texttt{filePath: string, smells: Smell[]} & Promise$<$void$>$ & None \\ \hline
  \texttt{getCachedSmells} & \texttt{filePath: string} & Smell[] \| \text{undefined} & None \\ \hline
  \texttt{hasCachedSmells} & \texttt{filePath: string} & boolean & None \\ \hline
  \texttt{clearAllCachedSmells} & None & Promise$<$void$>$ & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{cacheUpdatedEmitter}: EventEmitter - Emits cache update events
\item \texttt{fileStatuses}: Map$<$string, string$>$ - Tracks file statuses
\item \texttt{fileSmells}: Map$<$string, Smell[]$>$ - Stores cached smells
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item VS Code extension context is valid
\item File paths are normalized
\item Smell data structure is consistent
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{setCachedSmells(filePath, smells)}
\begin{itemize}
\item \textbf{Transition}: Stores smells in cache for specified file using \texttt{generateSmellId()}
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: None
\end{itemize}

\texttt{getCachedSmells(filePath)}
\begin{itemize}
\item \textbf{Transition}: Retrieves cached smells for file using \texttt{hasCachedSmells()}
\item \textbf{Output}: Array of smells or undefined
\item \textbf{Exception}: None
\end{itemize}

\texttt{hasCachedSmells(filePath)}
\begin{itemize}
\item \textbf{Transition}: Checks if file has cached smells
\item \textbf{Output}: boolean
\item \textbf{Exception}: None
\end{itemize}

\texttt{clearAllCachedSmells()}
\begin{itemize}
\item \textbf{Transition}: Removes all cached smells
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{generateSmellId(smell)}: Generates unique ID for smell
\item \texttt{generateFileHash(filePath)}: Generates hash for file content
\end{itemize}

\section{MIS of FilterManager}

\subsection{Module}
\texttt{FilterManager} manages filtering of detected smells.

\subsection{Uses}
\begin{itemize}
\item \texttt{CacheManager} for accessing smell data
\item \texttt{EventManager} for handling filter events
\item \texttt{HoverManager} for displaying filtered smells
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{toggleSmellFilter} & \texttt{smellKey: string} & void & None \\ \hline
  \texttt{editSmellFilterOption} & \texttt{item: \{smellKey: string, optionKey: string, value: any\}} & Promise$<$void$>$ & Validation Error \\ \hline
  \texttt{refresh} & None & void & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{filterState}: Map$<$string, boolean$>$ - Tracks filter states
\item \texttt{filterOptions}: Map$<$string, any$>$ - Stores filter options
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item Valid smell keys are provided
\item Filter options are properly configured
\item Cache manager is initialized
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{toggleSmellFilter(smellKey)}
\begin{itemize}
\item \textbf{Transition}: Toggles filter state for smell
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{editSmellFilterOption(item)}
\begin{itemize}
\item \textbf{Transition}: Updates filter option value
\item \textbf{Output}: Promise resolving to void
\item \textbf{Exception}: Throws validation error for invalid input
\end{itemize}

\texttt{refresh()}
\begin{itemize}
\item \textbf{Transition}: Updates filter display
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of EnergyMetrics}

\subsection{Module}
\texttt{EnergyMetrics} manages energy consumption measurements and metrics display.

\subsection{Uses}
\begin{itemize}
\item \texttt{ViewProvider} for displaying metrics
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{updateMetrics} & \texttt{filePath: string, carbonSaved: number, smellSymbol: string} & void & None \\ \hline
  \texttt{refresh} & None & void & None \\ \hline
  \texttt{getTreeItem} & \texttt{element: MetricTreeItem} & TreeItem & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{metricsData}: Record$<$string, MetricsDataItem$>$ - Stores metrics data
\item \texttt{onDidChangeTreeData}: EventEmitter - Emits tree data change events
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item Valid file paths are provided
\item Metrics data is properly formatted
\item Tree view is initialized
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{updateMetrics(filePath, carbonSaved, smellSymbol)}
\begin{itemize}
\item \textbf{Transition}: Updates metrics for file and smell using \texttt{calculateFileMetrics()} 
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{refresh()}
\begin{itemize}
\item \textbf{Transition}: Updates metrics display using \texttt{formatNumber()}
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{getTreeItem(element)}
\begin{itemize}
\item \textbf{Transition}: Creates tree item for metrics display
\item \textbf{Output}: TreeItem
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
\item \texttt{calculateFileMetrics(filePath, metricsData)}: Calculates metrics for file
\item \texttt{formatNumber(number)}: Formats number for display
\end{itemize}

\section{MIS of ViewProvider}

\subsection{Module}
\texttt{ViewProvider} manages the display of smells and metrics in VS Code.

\subsection{Uses}
None

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{refresh} & None & void & None \\ \hline
  \texttt{setStatus} & \texttt{filePath: string, status: string} & void & None \\ \hline
  \texttt{setSmells} & \texttt{filePath: string, smells: Smell[]} & void & None \\ \hline
  \texttt{removeFile} & \texttt{filePath: string} & boolean & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{fileStatuses}: Map$<$string, string$>$ - Tracks file statuses
\item \texttt{fileSmells}: Map$<$string, Smell[]$>$ - Stores smell data
\item \texttt{onDidChangeTreeData}: EventEmitter - Emits tree data change events
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item VS Code extension context is valid
\item File paths are normalized
\item Smell data structure is consistent
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{refresh()}
\begin{itemize}
\item \textbf{Transition}: Updates tree view display
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{setStatus(filePath, status)}
\begin{itemize}
\item \textbf{Transition}: Updates file status in view
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{setSmells(filePath, smells)}
\begin{itemize}
\item \textbf{Transition}: Updates smell data in view
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{removeFile(filePath)}
\begin{itemize}
\item \textbf{Transition}: Removes file from view
\item \textbf{Output}: boolean indicating success
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
None

\section{MIS of EventManager}

\subsection{Module}
\texttt{EventManager} manages event handling and propagation.

\subsection{Uses}
\begin{itemize}
\item \texttt{ViewProvider} for UI updates
\end{itemize}

\subsection{Syntax}

\textbf{Exported Constants:} None

\textbf{Exported Access Programs:}\\
\begin{tabularx}{\linewidth}{|l|>{\raggedright\arraybackslash}X|l|l|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exception} \\
  \hline
  \texttt{getStatus} & None & ServerStatusType & None \\ \hline
  \texttt{setStatus} & \texttt{newStatus: ServerStatusType} & void & None \\ \hline
  \texttt{on} & \texttt{event: string, listener: Function} & void & None \\ \hline
  \texttt{emit} & \texttt{event: string, data: any} & void & None \\
  \hline
\end{tabularx}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
\item \texttt{status}: ServerStatusType - Current server status
\item \texttt{eventEmitter}: EventEmitter - Event emitter instance
\end{itemize}

\subsubsection{Environment Variables}
None

\subsubsection{Assumptions}
\begin{itemize}
\item Event listeners are properly registered
\item Event types are consistent
\item Server status is valid
\end{itemize}

\subsubsection{Access Routine Semantics}
\texttt{getStatus()}
\begin{itemize}
\item \textbf{Transition}: Returns current server status
\item \textbf{Output}: ServerStatusType
\item \textbf{Exception}: None
\end{itemize}

\texttt{setStatus(newStatus)}
\begin{itemize}
\item \textbf{Transition}: Updates server status and emits event
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{on(event, listener)}
\begin{itemize}
\item \textbf{Transition}: Registers event listener
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\texttt{emit(event, data)}
\begin{itemize}
\item \textbf{Transition}: Emits event with data
\item \textbf{Output}: None
\item \textbf{Exception}: None
\end{itemize}

\subsubsection{Local Functions}
None

% \bibliographystyle {plainnat}
% \bibliography {../../../refs/References}

\newpage

\section{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\subsubsection*{Group Reflection}

\begin{enumerate}
  \item \textit{Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?}

  The decision to modularize the refactorers into specific "smell-focused" 
  components was largely inspired by a conversation with our supervisor, 
  who is also our primary stakeholder. During one of our discussions, our 
  supervisor suggested that the problem at hand had the potential to 
  evolve into a graduate-level reinforcement learning project. This 
  idea of managing multiple refactoring strategies and selecting the 
  best one based on certain conditions led to the insight that 
  organizing the refactorers by the specific types of code smells 
  they address would make the system more extensible. By focusing 
  each component on a particular code smell, we could later build 
  upon the design and possibly incorporate machine learning or 
  reinforcement learning strategies to optimize refactorer selection. 
  This modular approach would allow for easier integration of additional 
  strategies in the future, making the tool scalable as the project evolves.


  Another important design decision influenced by our supervisor was the 
  idea to validate the refactored code using a test suite. Our supervisor 
  emphasized that in a real-world application, validating the integrity 
  of the refactored code with a comprehensive test suite was a crucial step. 

  Both of these design decisions were informed by valuable input from our 
  supervisor, ensuring that the project stayed grounded in real-world 
  applicability and allowed for future enhancements and improvements.


  \item \textit{While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?}
  
  While creating the design document, several components of the project were revised to improve clarity and focus. Specifically, the list of code smells targeted by the refactoring library was refined by adding new smells that align more closely with our sustainability goals and removing others deemed less impactful. This required updates to the requirements document to ensure it accurately reflected the new scope of supported refactorings. Additionally, the decision was made to remove the metric reporting functionality due to its complexity and limited time, which led to corresponding modifications in both the requirements document and the VnV plan, where this feature had previously been considered for validation. Moreover, the reinforcement learning model, initially intended to optimise refactoring decisions, was excluded from the project due to time constraints and implementation challenges. This necessitated updates to the hazard analysis document to remove risks associated with this component and to better align the analysis with the reduced project scope. These changes ensure consistency and maintain a realistic and achievable project timeline. 

  \item \textit {What are the limitations of your solution?  Put another way, given unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)}

  The energy measurement library we selected, Codecarbon, proved to be less reliable 
  than anticipated, which affects the accuracy of some of our results. Ideally, 
  we would replace it with a more dependable resource. However, due to time 
  constraints and the inherent complexity of measuring CO2 emissions from code, 
  this isn't feasible within the scope of this project. For now, we are assuming 
  Codecarbon's reliability. In a real-world implementation, we would prioritize 
  using a more robust energy measurement system.

  \item \textit {Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)}

  We considered incorporating a machine learning aspect into the project, 
  specifically using reinforcement learning (RL) to manage the refactoring 
  process. The idea was to treat the selection and application of 
  refactoring strategies as a decision-making process, where an agent 
  could learn the best strategies over time based on rewards and outcomes.

  In this approach, the agent would represent the system that applies 
  different refactoring techniques to the code. The environment would 
  be the code itself, with various code smells and inefficiencies that 
  the agent needs to address. The actions the agent would take would 
  involve selecting and applying one of the predefined refactoring 
  strategies (like long lambda function or long parameter list). The reward 
  would be the resulting decrease in energy consumption (i.e., reduction 
  in CO2 emissions), measured after the code is refactored and executed. 
  The agent would receive a positive reward for actions that successfully 
  lead to more energy-efficient code and a negative reward for actions 
  that increase energy consumption. Over time, the agent would learn to 
  prioritize and apply the most effective refactoring techniques based 
  on the rewards it receives.


  While this machine learning solution seemed promising, there were a 
  few trade-offs to consider. First, implementing reinforcement 
  learning would significantly increase the complexity of the project. 
  It would require training data, fine-tuning the agent's learning parameters, 
  and ensuring that the agent's actions actually lead to measurable 
  improvements in CO2 efficiency. Additionally, RL would require 
  ongoing iteration to improve its performance, which could be time-consuming 
  and resource-intensive, especially given the limited time available 
  for the project.


  Another concern was that reinforcement learning, while powerful, 
  might not always be the most effective or efficient solution for 
  this kind of task. The selection of refactoring strategies is not 
  necessarily a highly complex decision-making process that requires 
  learning over time. Since we already have a set of predefined 
  strategies, a more direct, rule-based approach was more appropriate. 
  We could achieve the same results without the need for training the 
  agent or dealing with the unpredictability of machine learning models.


  Given these trade-offs, we opted to stick with the more straightforward 
  approach of selecting and applying refactoring strategies based on 
  predefined rules. This decision was driven by the need for a practical 
  and efficient solution within the given project constraints. While 
  reinforcement learning could be an interesting exploration for future 
  versions of the tool, the current design provides a reliable and 
  manageable way to achieve the desired results without adding 
  unnecessary complexity.


\end{enumerate}

\subsubsection*{Mya Hussain}

\begin{enumerate}
  \item \textit{What went well while writing this deliverable? }
  
  Writing the deliverable helped to clearly decompose the system into manageable modules.
  This ensured no functionality was missed in the implementation process and that all 
  components connected in a way that made sense. 

  \item \textit{What pain points did you experience during this deliverable, and how did you resolve them?}

  It was strange that we had already coded the project before completing this deliverable.
  It acted as more of a sanity check that our design decisions made sense rather than 
  an actual blueprint of what to do. This made this deliverable easier to write as 
  the code was already present but also made the work feel unnecessarily redundant i.e boring to do.
  It often felt like I was documenting things that were already clear or implemented. 
  This repetition made the process less engaging and, at times, a bit tedious.
  To resolve this, I focused on framing the document as an opportunity to validate 
  and formalize our design decisions, which helped shift the mindset from simply 
  checking off tasks to reaffirming the thought process behind our choices.
    
\end{enumerate}

\subsubsection*{Sevhena Walker}

\begin{enumerate}
  \item \textit{What went well while writing this deliverable? }

  Our team already had a pretty solid idea of how we wanted to break up our system, as well as the key components that should be involved, even before we started working on the MG and MIS documents. We had already coded a decent portion of the system and, in doing so, had explored and tested various design approaches and options. This hands-on experience gave us a strong foundation and a practical understanding of what worked and what didn't, which significantly influenced our final design choices. For example, we had already determined that the refactorers would be structured as individual classes inheriting from a common base class, which simplified documenting shared functionality in the MIS.

  \item \textit{What pain points did you experience during this deliverable, and how did you resolve them?}
  
  One of the biggest pain points was turning our informal design ideas and code into well-defined, modular components with clear inputs, outputs, and semantics. We had to carefully review the existing code to make sure the documentation matched its behaviour while keeping things flexible for future changes. We also ran into some inconsistencies that required minor refactoring to clean up our interfaces. Another tricky part was finding the right balance between providing enough detail and keeping the documentation readable without going too deep into implementation. We tackled these problems by reviewing everything multiple times, getting feedback, and simplifying where we could to make things clearer.

\end{enumerate}

\subsection*{Nivetha Kuruparan}

\begin{enumerate}
  \item \textit{What went well while writing this deliverable? }
  Planning out the different modules early on was incredibly helpful for me. It allowed me to clearly identify how various parts of the system interact and what functionality could be combined or separated. This structured approach not only helped in designing the system but also made it easier to focus on what each module should accomplish, ensuring no major functionality was overlooked.

  \item \textit{What pain points did you experience during this deliverable, and how did you resolve them?}
    It was challenging for me to think through each module thoroughly and ensure that every input, output, and state variable was captured accurately. This required going through the implementation multiple times and considering edge cases that might not have been obvious at first. Breaking the process into smaller, more manageable tasks and carefully reviewing each module helped resolve this challenge.

    
\end{enumerate}

\subsection*{Ayushi Amin}

\begin{enumerate}
  \item \textit{What went well while writing this deliverable? }
  Honestly, once I got into it, things flowed pretty smoothly. Breaking everything down into 
  smaller sections helped a ton. It made the whole thing feel less intimidating. I also felt like 
  I had a good understanding of how the modules all connected, which made it easier to explain things.
  We all had our own parts to work on based on the modules we have and were going to create so it was easier to 
  work on something I was familiar with. Also, talking it through with my teammates about some of the trickier 
  parts really helped me feel more confident about what I was writing. We all did code reviews and helped eachother out on
  parts we didn't quite get or thought we got. Overall, it felt pretty satisfying to see it all come together.
  
  \item \textit{What pain points did you experience during this deliverable, and how did you resolve them?}
  I think the hardest part of this was visualising extra dependencies and functions I would need to create to make my 
  module work. We had coded out a portion of it but it did not include everything. I had to make sure I was not missing 
  anything important. It felt like I was stuck in this loop of overthinking every little detail. To get past it, I took a 
  break and came back with a fresh perspective, which helped a bit. I also hit up one of my teammates to talk through the 
  parts I was struggling with. They gave me some ideas and helped me confirm I was on the right track since some of the 
  modules I did were similar to theirs so we were able to collaborate easily. After that, things did not feel as stressful, 
  and I was able to wrap it up.
  
\end{enumerate}

\subsection*{Tanveer Brar}

\begin{enumerate}
  \item \textit{What went well while writing this deliverable? }
  The best part about writing this deliverable was getting the chance to design the user interface before having implemented it. The Source Code Optimizer has already been designed
  and implemented as a result of the POC assignment in November. We had not implemented the VS Code Plugin for it yet, so getting the chance to actually think about its 
  design was very rewarding(especially since most academic projects I have done before either involved no design component or very minimal for a small program). Each modules has clear 
  responsibilities, which helped me anticipate all needed requirements for this plugin through a logical framework(POC implementation was a lot of trial and error).
  The other good thing were the built in labels for anticipated changes and modules, which helped me easily write down the traceability matrix.
  
  \item \textit{What pain points did you experience during this deliverable, and how did you resolve them?}
  One of the biggest challenges that I faced was identifying the correct module for each anticipated change in the traceability matrix. My team mate had worked on the anticipated
  changes, Some of these changes had overlapping responsibilities across modules, so I carefully reviewd the module responsibilities over again to be able to point out the modules for 
  each change. It needed a lot of cross referencing the module guide and anticipated changes to make sure nothing was missde. 
  Also, when determining module dependencies in the "Uses" section for each module's decomposition, I was not fully sure about which modules should depend on which for the VS Code Plugin.
  This is because there can be multiple possible ways, for example the Plugin Initializer or Smell Detector being able to directly call Source Code Optimizer. While resolving this, I realized that 
  while there is no one perfect mapping of dependencies, the goal should be to be as modular as possible and apply the seperation of concerns principle. This is why, for example, the Backend Communicator 
  is the only module in the design that communicates with Source Code Optimizer.
\end{enumerate}


\end{document}